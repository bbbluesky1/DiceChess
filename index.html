<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DiceChess</title>
  <style>
    :root {
  --white-cell: #EBECD0;
  --black-cell: #739552;
  --board-size: min(80vmin, 480px);
  --cell-size: calc(var(--board-size) / 8);
}


    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #dbe9f4, #f7f7f7);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .menu-toggle {
      display: flex; /* ‚Üê PC „Åß„ÇÇÂ∏∏„Å´Ë°®Á§∫ */
      flex-direction: column;
      cursor: pointer;
      gap: 4px;
    }


    .menu-toggle div {
      width: 25px;
      height: 3px;
      background-color: #fff;
    }

    nav {
      position: absolute;
      top: 100%;
      right: 0;
      background-color: #444;
      color: #fff;
      display: none;
      flex-direction: column;
      min-width: 150px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    nav a {
      padding: 0.8rem 1rem;
      text-decoration: none;
      color: #fff;
      border-bottom: 1px solid #555;
    }

    nav a:hover {
      background-color: #555;
    }

    .show-menu nav {
      display: flex;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: #333;
    }

    #status {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #444;
    }

    table {
      border-collapse: collapse;
      border: 2px solid #222;
      width: var(--board-size);
      height: var(--board-size);
      aspect-ratio: 1 / 1;
      table-layout: fixed;
    }

    td {
      width: var(--cell-size);
      height: var(--cell-size);
      position: relative;
      perspective: 1000px;
      padding: 0;
    }

    td.white { background-color: var(--white-cell); }
    td.black { background-color: var(--black-cell); }
    td.selected { outline: 3px solid yellow; }

    .dice {
      width: 90%;
      height: 90%;
      position: absolute;
      top: 5%;
      left: 5%;
      transform-style: preserve-3d;
      transform-origin: center;
      transition: transform 0.5s ease-in-out;
    }

    .face {
      position: absolute;
      width: 100%;
      height: 100%;
      background: #fff;
      border: 1px solid #aaa;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .pip {
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      margin: 2px;
    }

    .front  { transform: rotateY(0deg) translateZ(15px); }
    .back   { transform: rotateY(180deg) translateZ(15px); }
    .right  { transform: rotateY(90deg) translateZ(15px); }
    .left   { transform: rotateY(-90deg) translateZ(15px); }
    .top    { transform: rotateX(90deg) translateZ(15px); }
    .bottom { transform: rotateX(-90deg) translateZ(15px); }

    .dice.king {
      outline: 2px solid red;
      outline-offset: 1px;
      border-radius: 6px;
    }

    .ghost-wrapper {
      opacity: 0.5;
      transform: scale(0.5);
      filter: brightness(60%);
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 10;
      pointer-events: none;
    }

    .ghost-dice .face {
      border: 1px dashed #000;
    }

    @media (max-width: 768px) {
      .menu-toggle {
        display: flex;
      }

      nav {
        right: 0;
        top: 60px;
      }

      h1 {
        font-size: 1.5rem;
      }

      #status {
        font-size: 1rem;
      }

      :root {
        --board-size: 85vw;
      }

      .pip {
        width: 4px;
        height: 4px;
        margin: 1px;
      }

      .dice {
        width: 95%;
        height: 95%;
        top: 2.5%;
        left: 2.5%;
      }
    }

/* „Éò„ÉÉ„ÉÄ„Éº */
header {
  height: 60px;
  background-color: #222;
  color: white;
  padding: 0 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: fixed;
  width: 100%;
  top: 0;
  z-index: 1000;
}

/* „É°„Ç§„É≥„Ç®„É™„Ç¢Ôºö„Éò„ÉÉ„ÉÄ„Éº„ÅÆ‰∏ã„Å´„ÄÅÊ®™‰∏¶„Å≥ */
main#game-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: flex-start;
  padding-top: 80px;
  gap: 2rem;
  max-width: 1200px;
  margin: 0 auto;
  width: 100%;
}


/* Áõ§Èù¢„Ç®„É™„Ç¢ */
#board-container {
  flex-shrink: 0;
  min-width: 400px;
  max-width: 700px;
}

/* „É≠„Éú„ÉÉ„Éà„Ç®„É™„Ç¢ */
#robot-area {
  width: 250px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

#robot-avatar {
  width: 60px;
  height: auto;
}

#robot-bubble {
  background-color: #fff;
  border: 2px solid #888;
  border-radius: 16px;
  padding: 10px 14px;
  max-width: 200px;
  font-size: 14px;
  position: relative;
  box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
}

#robot-bubble::after {
  content: "";
  position: absolute;
  left: -10px;
  top: 10px;
  width: 0;
  height: 0;
  border: 10px solid transparent;
  border-right-color: #fff;
}

/* „Çπ„Éû„ÉõË°®Á§∫ÊôÇ„ÅÆ„Çπ„Çø„Ç§„É´ */
@media (max-width: 768px) {
  main#game-container {
    flex-direction: column;
    align-items: center;
    padding-top: 80px;
  }

  #board-container {
    display: flex;
    justify-content: center;
    width: 100%;
  }

  #robot-area {
    order: -1; /* ‚Üê ‰∏ä„Å´Ë°®Á§∫„Åï„Åõ„Çã */
    width: 100%;
    margin-bottom: 1rem;
    align-items: center;
  }

  #robot-bubble::after {
    top: -10px;
    left: 20px;
    border: 10px solid transparent;
    border-bottom-color: #fff;
    border-right-color: transparent;
  }
}

  </style>
</head>
<body>


  <header>
    <div class="logo">üé≤ DiceChess</div>
    <div class="menu-toggle" onclick="document.body.classList.toggle('show-menu')">
      <div></div><div></div><div></div>
    </div>
    <nav>
      <a href="./tutorial.html">„É´„Éº„É´</a>
      <a href="./index3.html">„Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶</a>
    </nav>
  </header>

  <main id="game-container">
  <div id="board-container">
    <table id="board"></table>
    <audio id="dice-roll-sound" src="./roll.mp3" preload="auto"></audio>
  </div>

  <div id="robot-area">
    <img src="./waving-287_256.gif" alt="Bot" id="robot-avatar" />
    <div id="robot-bubble">„Åì„Çì„Å´„Å°„ÅØÔºÅ„Ç≤„Éº„É†„ÇíÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜÔºÅ</div>
  </div>
</main>


<script>

  function updateRobotMessage(message) {
  const bubble = document.getElementById('robot-bubble');
  if (bubble) {
    bubble.textContent = message;
  }
}

const board = document.getElementById("board");
//const status = document.getElementById("status");
const SIZE = 8;
let selected = null;
let currentPlayer = "white";
const state = [];

const diceRotations = {
  1: 'rotateX(0deg) rotateY(0deg)',
  2: 'rotateX(-90deg) rotateY(0deg)',
  3: 'rotateY(-90deg)',
  4: 'rotateY(90deg)',
  5: 'rotateX(90deg) rotateY(0deg)',
  6: 'rotateX(180deg) rotateY(0deg)'
};

const pipsMap = {
  1: [4],
  2: [0, 8],
  3: [0, 4, 8],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8]
};

function createPiece(top, color, player, isKing = false) {
  let die;

  if (player === "black") {
    // Â∑¶Âè≥„ÉªÂâçÂæå„ÇíÂèçËª¢
    die = {
      top: top,
      bottom: 7 - top,
      left: 3,   // ‚Üê ÂèçËª¢
      right: 4,  // ‚Üê ÂèçËª¢
      front: 5,  // ‚Üê ÂèçËª¢
      back: 2,   // ‚Üê ÂèçËª¢
    };
  } else {
    // ÈÄöÂ∏∏ÔºàÁôΩÔºâ
    die = {
      top: top,
      bottom: 7 - top,
      left: 4,
      right: 3,
      front: 2,
      back: 5,
    };
  }

  return { ...die, color, player, isKing };
}

function playDiceRollSound() {
  const audio = document.getElementById('dice-roll-sound');
  if (audio) {
    audio.currentTime = 0; // Â∑ª„ÅçÊàª„ÅóÔºàÈÄ£Á∂öÂÜçÁîüÁî®Ôºâ
    audio.play();
  }
}

function rollDie(die, direction) {
  const newDie = { ...die };

  switch (direction) {
    case "up":
      newDie.top = die.back;
      newDie.bottom = die.front;
      newDie.front = die.top;
      newDie.back = die.bottom;
      break;
    case "down":
      newDie.top = die.front;
      newDie.bottom = die.back;
      newDie.front = die.bottom;
      newDie.back = die.top;
      break;
    case "left":
      newDie.top = die.right;
      newDie.bottom = die.left;
      newDie.left = die.top;
      newDie.right = die.bottom;
      break;
    case "right":
      newDie.top = die.left;
      newDie.bottom = die.right;
      newDie.left = die.bottom;
      newDie.right = die.top;
      break;
  }

  return newDie;
}

function moveDie(originalDie, dx, dy) {
  let die = { ...originalDie };

  const step = (dir, count) => {
    for (let i = 0; i < count; i++) {
      die = rollDie(die, dir);
    }
  };

  if (dy < 0) step("up", -dy);
  else if (dy > 0) step("down", dy);

  if (dx < 0) step("left", -dx);
  else if (dx > 0) step("right", dx);

  return die;
}


function setup() {
  for (let r = 0; r < SIZE; r++) {
    const row = [];
    const tr = document.createElement("tr");
    for (let c = 0; c < SIZE; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;
      td.className = (r + c) % 2 === 0 ? "white" : "black";
      td.addEventListener("click", onCellClick);
      tr.appendChild(td);
      row.push(null);
    }
    board.appendChild(tr);
    state.push(row);
  }

  const backRank = [5, 3, 3, 6, 2, 3, 3, 5];
  const reversedBackRank = [...backRank].reverse();
  for (let i = 0; i < SIZE; i++) {
  state[7][i] = createPiece(backRank[i], "", "white", backRank[i] === 2);
  state[6][i] = createPiece(1, "", "white");

  state[0][i] = createPiece(reversedBackRank[i], "", "black", reversedBackRank[i] === 2);
  state[1][i] = createPiece(1, "", "black");
}


  render();
}

let ghostMoves = [];

function getGhostMoves(piece, sr, sc) {
  if (!piece) return [];

  const moves = [];
  const directions = [
    { dr: -1, dc: 0 }, // ‰∏ä
    { dr: 1, dc: 0 },  // ‰∏ã
    { dr: 0, dc: -1 }, // Â∑¶
    { dr: 0, dc: 1 }   // Âè≥
  ];

  directions.forEach(({ dr, dc }) => {
    for (let i = 1; i <= piece.top; i++) {
      const r = sr + dr * i;
      const c = sc + dc * i; //
      if (r < 0 || r >= SIZE || c < 0 || c >= SIZE) break;

      const target = state[r][c];
      const newDie = moveDie(piece, dc * i, dr * i);

      if (target) {
        if (target.player === piece.player) break;
            
        if (piece.top < target.top) {
          moves.push({ r, c, piece: { ...piece, ...newDie } });
        }
      
        break;
      } else {
        moves.push({ r, c, piece: { ...piece, ...newDie } });
      }
    }
  });

  return moves;
}

function createDiceElement(piece, isGhost = false) {
  const wrapper = document.createElement("div"); // „Ç¥„Éº„Çπ„ÉàÁî®„É©„ÉÉ„Éë„Éº
  const dice = document.createElement("div");
  dice.id = `piece-${piece.id}`; // IDËøΩÂä†

  const colorClass = piece.isKing
    ? (piece.player === "white" ? "red-dice" : "blue-dice")
    : (piece.player === "white" ? "white-dice" : "black-dice");

  dice.className = `dice ${colorClass}`;
  dice.style.transform = diceRotations[piece.top];
  dice.dataset.rotation = "0,0";

  if (isGhost) {
    wrapper.className = "ghost-wrapper";
    dice.classList.add("ghost-dice");
  }

  ["front", "back", "right", "left", "top", "bottom"].forEach((side) => {
    const face = document.createElement("div");
    face.className = `face ${side}`;
    face.style.background = piece.isKing
      ? (piece.player === "white" ? "#c00" : "#06c")
      : (piece.player === "white" ? "#fff" : "#222");

    const faceNumberMap = {
      front: 1,
      back: 6,
      right: 3,
      left: 4,
      top: 2,
      bottom: 5,
    };
    const faceNum = faceNumberMap[side];
    pipsMap[faceNum].forEach(i => {
      const pip = document.createElement("div");
      pip.className = "pip";
      pip.style.backgroundColor = piece.player === "white" ? "#000" : "#fff";
      face.appendChild(pip);
    });
    dice.appendChild(face);
  });

  if (isGhost) {
    wrapper.appendChild(dice);
    return wrapper;
  }

  return dice;
}

// „Çµ„Ç§„Ç≥„É≠„ÅÆÁ¥ØÁ©çÂõûËª¢ËßíÂ∫¶Ôºà„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Åß„ÇÇ„ÄÅdiceElement.dataset„Åß„ÇÇÂèØÔºâ
let rotationX = 0;
let rotationY = 0;
let rotationZ = 0;

function animateDiceMoveSmooth(diceElement, dx, dy, duration = 0.3) {
  return new Promise((resolve) => {
    const tileSize = 60;
    if (dx === 0 && dy === 0 || duration <= 0) {
      resolve();
      return;
    }

    const moveX = dx * tileSize;
    const moveY = dy * tileSize;

    // „Çµ„Ç§„Ç≥„É≠„ÅÆÂõûËª¢Ôºà1„Éû„ÇπÂàÜ„Å†„ÅëÂØæÂøúÔºâ
    const rotateX = dy === -1 ? 90 : dy === 1 ? -90 : 0;
    const rotateY = dx === 1 ? 90 : dx === -1 ? -90 : 0;

    // ÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å®ÂõûËª¢„ÇíÂèñÂæó
    const startX = parseFloat(diceElement.dataset.posX || "0");
    const startY = parseFloat(diceElement.dataset.posY || "0");
    const startRotateX = parseFloat(diceElement.dataset.rotateX || "0");
    const startRotateY = parseFloat(diceElement.dataset.rotateY || "0");

    const targetX = startX + moveX;
    const targetY = startY + moveY;
    const targetRotateX = startRotateX + rotateX;
    const targetRotateY = startRotateY + rotateY;

    diceElement.style.position = "absolute";

    const startTime = performance.now();

    function step(now) {
      const elapsed = (now - startTime) / 1000;
      const progress = Math.min(elapsed / duration, 1);

      const currentX = startX + (targetX - startX) * progress;
      const currentY = startY + (targetY - startY) * progress;
      const currentRotateX = startRotateX + (targetRotateX - startRotateX) * progress;
      const currentRotateY = startRotateY + (targetRotateY - startRotateY) * progress;

      diceElement.style.transform = `
        translate(${currentX}px, ${currentY}px)
        rotateX(${currentRotateX}deg)
        rotateY(${currentRotateY}deg)
      `;

      if (progress < 1) {
        requestAnimationFrame(step);
      } else {
        // ÊúÄÁµÇÁä∂ÊÖã„Å´Âõ∫ÂÆö
        diceElement.dataset.posX = targetX;
        diceElement.dataset.posY = targetY;
        diceElement.dataset.rotateX = targetRotateX;
        diceElement.dataset.rotateY = targetRotateY;

        diceElement.style.transform = `
          translate(${targetX}px, ${targetY}px)
          rotateX(${targetRotateX}deg)
          rotateY(${targetRotateY}deg)
        `;
        resolve();
      }
    }

    requestAnimationFrame(step);
  });
}

async function animateMoveAndUpdateState(sr, sc, directions, piece) {
  let currentDie = { ...piece };
  let row = sr;
  let col = sc;

  for (const dir of directions) {
    const dr = dir === "up" ? -1 : dir === "down" ? 1 : 0;
    const dc = dir === "left" ? -1 : dir === "right" ? 1 : 0;
    const nr = row + dr;
    const nc = col + dc;
    
    const diceElem = board.rows[row].cells[col].querySelector(".dice");

    // Âá∫ÁõÆÊõ¥Êñ∞
    currentDie = rollDie(currentDie, dir);

    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
    await animateDiceMoveSmooth(diceElem, dc, dr);
    playDiceRollSound();

    // DOMÊìç‰Ωú„Åß„Éû„ÇπÁßªÂãïÔºàrender„Å™„ÅóÔºâ
    board.rows[row].cells[col].innerHTML = "";
    board.rows[nr].cells[nc].appendChild(diceElem);

    // ÂÜÖÈÉ®Áä∂ÊÖãÊõ¥Êñ∞
    state[nr][nc] = { ...piece, ...currentDie };
    state[row][col] = null;

    // dice „ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
    render();

    row = nr;
    col = nc;
  }

  ghostMoves = [];
  selected = null;
  render(); // ÊúÄÂæå„Å´„Åæ„Å®„ÇÅ„Å¶ÂÜçÊèèÁîª
}



function moveDie(originalDie, dx, dy) {
  let die = { ...originalDie };

  const step = (dir, count) => {
    for (let i = 0; i < count; i++) {
      die = rollDie(die, dir);
    }
  };

  if (dy < 0) step("up", -dy);
  else if (dy > 0) step("down", dy);

  if (dx < 0) step("left", -dx);
  else if (dx > 0) step("right", dx);

  return die;
}




function render() {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const td = board.rows[r].cells[c];
      td.classList.remove("selected");
      td.innerHTML = "";
      const piece = state[r][c];
      if (piece) {
        const dice = createDiceElement(piece);
        td.appendChild(dice);
      }
    }
  }

  // „Ç¥„Éº„Çπ„ÉàÊèèÁîª
console.log(`Ghost moves: `, ghostMoves);
ghostMoves.forEach(({ r, c, piece }) => {
  const td = board.rows[r].cells[c];
  const ghost = createDiceElement(piece, true);
  console.log(`Appending ghost to cell at [${r}, ${c}]`);
  td.appendChild(ghost);
});


}

async function onCellClick(e) {
  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);
  const cell = state[row][col];
  ghostMoves = getGhostMoves(selected, row, col);
  render();

  if (!selected && cell && cell.player === currentPlayer) {
    selected = [row, col];
    ghostMoves = getGhostMoves(cell, row, col);
    render();
    board.rows[row].cells[col].classList.add("selected");
    return;
  }

  if (selected) {
    const [sr, sc] = selected;
    const piece = state[sr][sc];
    const target = state[row][col];

     // Ëá™Èßí„Åå„Çø„Éº„Ç≤„ÉÉ„Éà„Å´„ÅÑ„Åü„ÇâÂãï„Åë„Å™„ÅÑ
  if (target && target.player === piece.player) {
    selected = null;
    ghostMoves = [];
    render();
    return;
  }

    const dr = row - sr;
    const dc = col - sc;
    const isStraight = (dr === 0 || dc === 0);
    const distance = Math.max(Math.abs(dr), Math.abs(dc));
    const inRange = distance <= piece.top;

    if (!isStraight || !inRange) {
      selected = null;
      ghostMoves = [];
      render();
      return;
    }

    const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
    const stepC = dc === 0 ? 0 : dc / Math.abs(dc);
    let r = sr + stepR;
    let c = sc + stepC;
    let foundEnemy = null;

    while (r !== row || c !== col) {
      const mid = state[r][c];
      if (mid) {
        if (mid.player === piece.player) {
          selected = null;
          ghostMoves = [];
          render();
          return;
        } else {
          if (foundEnemy) {
            selected = null;
            ghostMoves = [];
            render();
            return;
          }
          foundEnemy = { ...mid, row: r, col: c };
        }
      }
      r += stepR;
      c += stepC;
    }

    const dx = col - sc;
    const dy = row - sr;
    const newDie = moveDie(piece, dx, dy);

    const diceElement = board.rows[sr].cells[sc].querySelector(".dice");

    //animation
    const directions = [];
    for (let i = 0; i < Math.abs(dx); i++) directions.push(dx > 0 ? "right" : "left");
    for (let i = 0; i < Math.abs(dy); i++) directions.push(dy > 0 ? "down" : "up");
    await animateMoveAndUpdateState(sr, sc, directions, piece);


    // „Åì„Åì„Åã„ÇâÁä∂ÊÖãÊõ¥Êñ∞
    if (target) {
      if (target.player !== piece.player && piece.top < target.top) {
        state[row][col] = { ...piece, ...newDie };
        state[sr][sc] = null;
        ghostMoves = [];
        selected = null;
        render();
         if (currentPlayer === 'white' && state[row][col]?.isKing && state[row][col]?.color === 'black') {
          alert("White wins!");
          location.reload();
          return;
        }
        if (checkmate("black")) {
          setTimeout(() => {
            alert("White wins!");
            location.reload();
          }, 2000);
        return;
        }
      } else {
        selected = null;
        ghostMoves = [];
        render();
        return;
      }
    }

    if (foundEnemy) {
      if (piece.top < foundEnemy.top && foundEnemy.row === row && foundEnemy.col === col) {
        state[row][col] = { ...piece, ...newDie };
        state[sr][sc] = null;
        ghostMoves = [];
        selected = null;
        render();
        if (currentPlayer === 'white' && state[row][col]?.isKing && state[row][col]?.color === 'black') {
          alert("White wins!");
          location.reload();
          return;
        }
        if (checkmate("black")) {
          setTimeout(() => {
            alert("White wins!");
            location.reload();
          }, 2000);
          return;
        }
        return;
      } else {
        selected = null;
        ghostMoves = [];
        render();
        return;
      }
    }

    // ÈÄöÂ∏∏ÁßªÂãï
    state[row][col] = { ...piece, ...newDie };
    state[sr][sc] = null;
    ghostMoves = [];
    selected = null;
    render();
    endTurn(piece.player);
  }
}






function hasPieceInBetween(sr, sc, row, col, board = state) {
  const dr = row - sr;
  const dc = col - sc;
  const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
  const stepC = dc === 0 ? 0 : dc / Math.abs(dc);
  let r = sr + stepR;
  let c = sc + stepC;

  while (r !== row || c !== col) {
    if (board[r][c]) {
      return { blocked: true, piece: board[r][c] };
    }
    r += stepR;
    c += stepC;
  }
  return { blocked: false, piece: null };
}

function endTurn(player) {
  currentPlayer = player === "white" ? "black" : "white";
  updateRobotMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}„ÅÆ„Çø„Éº„É≥`);
  //status.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}„ÅÆ„Çø„Éº„É≥`;
  botTurn();
}

/*
function checkWin(attacker) {// checkmate()„Å´Â§âÊõ¥
  if (checkmate(attacker)) {
    alert(`checkmate! ${attacker} wins!`);
    location.reload();
    return;
  }
  endTurn(attacker);
}
  */






async function botTurn() {
  updateRobotMessage("BlackÔºàBotÔºâËÄÉ„Åà‰∏≠...");
  //status.textContent = "BlackÔºàBotÔºâËÄÉ„Åà‰∏≠...";

  // ËÄÉ„Åà‰∏≠„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆ‰ª£„Çè„Çä„Å´Â∞ë„ÅóÂæÖ„Å§Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
  await new Promise(resolve => setTimeout(resolve, 300));

  const moves = generateMoves("black", state);
  if (moves.length === 0) {
    alert("Bot„ÅØÂãï„Åë„Åæ„Åõ„ÇìÔºÅ");
    currentPlayer = "white";
    updateRobotMessage("White„ÅÆ„Çø„Éº„É≥");
    //status.textContent = "White„ÅÆ„Çø„Éº„É≥";
    return;
  }

  let bestScore = -Infinity;
  let bestMove = null;

  for (let move of moves) {
    const testState = applyMove(cloneBoard(state), move);
    let score = minimax(testState, 4, -Infinity, Infinity, false);

    const [tr, tc] = move.to;
    if (state[tr][tc] && state[tr][tc].color === "white") {
      score += 100;
      if (state[tr][tc].isKing) score += 300;
    }

    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }

  if (bestMove) {
    const [fr, fc] = bestMove.from;
    const [tr, tc] = bestMove.to;
    const piece = state[fr][fc];
    const dx = tc - fc;
    const dy = tr - fr;
    const newDie = moveDie(piece, dx, dy);

    const diceElement = board.rows[fr].cells[fc].querySelector(".dice");

    //animation
    render(); // „Åæ„ÅöÊèèÁîª
    await new Promise(requestAnimationFrame); // 1„Éï„É¨„Éº„É†ÂæÖ„Å§„Åì„Å®„ÅßDOM„ÅåÁ¢∫ÂÆü„Å´ÂèçÊò†„Åï„Çå„Çã
    const directions = [];
    for (let i = 0; i < Math.abs(dx); i++) directions.push(dx > 0 ? "right" : "left");
    for (let i = 0; i < Math.abs(dy); i++) directions.push(dy > 0 ? "down" : "up");
    await animateMoveAndUpdateState(fr, fc, directions, piece);

    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Âæå„Å´ÁßªÂãï„ÇíÂèçÊò†
    state[tr][tc] = { ...piece, ...newDie };
    state[fr][fc] = null;
    render();

   if (currentPlayer === 'black' && state[tr][tc]?.isKing && state[tr][tc]?.color === 'white') {
  alert("Black wins!");
  location.reload();
  return;
}
  if (checkmate("white")) {
    setTimeout(() => {
      alert("Black wins!");
      location.reload();
    }, 2000);
    return;
  }
}

  currentPlayer = "white";
  updateRobotMessage("White„ÅÆ„Çø„Éº„É≥");
  //status.textContent = "White„ÅÆ„Çø„Éº„É≥";
  selected = null;
}





function cloneBoard(boardState) {
  return boardState.map(row => row.map(cell => cell ? { ...cell } : null));
}

function evaluateBoard(board) {
  let score = 0;

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (piece) {
        let baseValue = 10 + piece.top; // Âü∫Êú¨ÂÄ§ + Âá∫ÁõÆÔºàÊîªÊíÉÂäõÔºâ
        if (piece.isKing) baseValue += 50; // „Ç≠„É≥„Ç∞„ÅØ„Åï„Çâ„Å´È´òË©ï‰æ°
        // Áõ§„ÅÆÂâçÊñπ„Å´„ÅÑ„Çã„Åª„Å©È´òË©ï‰æ°ÔºàÂâç„Å´Âá∫„Å¶„ÅÑ„ÇãÈßí„ÅØÁ©çÊ•µÁöÑÔºâ
        const advanceBonus = piece.player === "black" ? (7 - r) : r;
        baseValue += advanceBonus;

        // ÊïµÈßí„Å®„Åó„Å¶„Éû„Ç§„Éä„Çπ„ÄÅÂë≥Êñπ„Å®„Åó„Å¶„Éó„É©„Çπ
        score += piece.player === "black" ? baseValue : -baseValue;
      }
    }
  }

  return score;
}

function hasBlockingPiece(sr, sc, er, ec, board) {
  const dr = Math.sign(er - sr);
  const dc = Math.sign(ec - sc);
  let r = sr + dr;
  let c = sc + dc;
  while (r !== er || c !== ec) {
    if (board[r][c]) return true;
    r += dr;
    c += dc;
  }
  return false;
}

function getBlockingPosition(sr, sc, dr, dc, board) {
  let r = sr + dr;
  let c = sc + dc;
  while (r >= 0 && r < 8 && c >= 0 && c < 8) {
    if (board[r][c]) return [r, c];
    r += dr;
    c += dc;
  }
  return [-1, -1];
}


function generateMoves(player, boardState) {
  const moves = [];
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = boardState[r][c];
      if (!piece || piece.player !== player) continue;
      const dirs = [[1,0],[0,1],[-1,0],[0,-1]];

      for (const [dr, dc] of dirs) {
        for (let dist = 1; dist <= piece.top; dist++) {
          const nr = r + dr * dist;
          const nc = c + dc * dist;
          if (nr < 0 || nc < 0 || nr >= 8 || nc >= 8) break;

          const target = boardState[nr][nc];

          // ‰∏≠Èñì„Å´Èßí„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅ„Åù„Åì„ÅåÊïµ„Å™„Çâ„Åù„Åì„ÅßÊ≠¢„Åæ„Çã
          if (hasBlockingPiece(r, c, nr, nc, boardState)) {
            const [br, bc] = getBlockingPosition(r, c, dr, dc, boardState);
            const blocking = boardState[br][bc];
            if (blocking && blocking.player !== player && piece.top < blocking.top) {
              // Êïµ„Åß„ÄÅ„Åã„Å§Â§ß„Åç„ÅÑÁõÆ„Å™„ÅÆ„ÅßÂèñ„Çå„Çã ‚Üí move„Å´ËøΩÂä†
              moves.push({ from: [r, c], to: [br, bc] });
            }
            break; // „Åù„Çå‰ª•ÈôçÈÄ≤„ÇÅ„Å™„ÅÑ
          }

          // Êïµ„Åå„ÅÑ„Å¶Âèñ„Çå„ÇãÂ†¥Âêà
          if (target) {
            if (target.player === player) break; // Âë≥Êñπ ‚Üí ÈÄ≤„ÇÅ„Å™„ÅÑ
            if (piece.top < target.top) {
              moves.push({ from: [r, c], to: [nr, nc] });
            }
            break;
          }

          // Á©∫„Åç„Éû„Çπ
          moves.push({ from: [r, c], to: [nr, nc] });
        }
      }
    }
  }
  return moves;
}



function minimax(boardState, depth, alpha, beta, maximizingPlayer) {
  const winner = checkWinner(boardState);
  if (winner === "black") return 1000;
  if (winner === "white") return -1000;

  if (depth === 0) return evaluateBoard(boardState);

  const player = maximizingPlayer ? "black" : "white";
  const moves = generateMoves(player, boardState);

  if (maximizingPlayer) {
    let maxEval = -Infinity;
    for (const move of moves) {
      const newBoard = applyMove(cloneBoard(boardState), move);
      const eval = minimax(newBoard, depth - 1, alpha, beta, false);
      maxEval = Math.max(maxEval, eval);
      alpha = Math.max(alpha, eval);
      if (beta <= alpha) break; // Œ≤„Ç´„ÉÉ„Éà
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const move of moves) {
      const newBoard = applyMove(cloneBoard(boardState), move);
      const eval = minimax(newBoard, depth - 1, alpha, beta, true);
      minEval = Math.min(minEval, eval);
      beta = Math.min(beta, eval);
      if (beta <= alpha) break; // Œ±„Ç´„ÉÉ„Éà
    }
    return minEval;
  }
}


function applyMove(boardState, move) {
  const [fr, fc] = move.from;
  const [tr, tc] = move.to;
  const piece = boardState[fr][fc];
  const dx = tc - fc;
  const dy = tr - fr;
  const newDie = moveDie(piece, dx, dy);
  boardState[tr][tc] = { ...piece, ...newDie };
  boardState[fr][fc] = null;
  return boardState;
}

function checkWinner(boardState) {
  let hasWhiteKing = false;
  let hasBlackKing = false;
  for (let row of boardState) {
    for (let piece of row) {
      if (piece?.isKing) {
        if (piece.player === "white") hasWhiteKing = true;
        if (piece.player === "black") hasBlackKing = true;
      }
    }
  }
  if (!hasWhiteKing) return "black";
  if (!hasBlackKing) return "white";
  return null;
}

function isInCheck(color) {
  return isInCheckAfterMove(color, state);
}


function isInCheckAfterMove(color, board) {
  let kingPosition = null;

  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col];
      if (piece && piece.player === color && piece.isKing) {
        kingPosition = { row, col };
        break;
      }
    }
    if (kingPosition) break;
  }

  if (!kingPosition) return true; // „Ç≠„É≥„Ç∞„Åå„ÅÑ„Å™„ÅÑÔºùÊó¢„Å´Âèñ„Çâ„Çå„Å¶„Çã

  const opponent = color === "white" ? "black" : "white";
  const oppMoves = generateMoves(opponent, board);
  for (const move of oppMoves) {
    const [tr, tc] = move.to;
    if (tr === kingPosition.row && tc === kingPosition.col) {
      return true;
    }
  }

  return false;
}

function checkmate(color) {
  if (!isInCheck(color)) return false; // „Åæ„Åö„ÉÅ„Çß„ÉÉ„ÇØ„Åß„Å™„Åë„Çå„Å∞Ë©∞„Åø„Åß„Å™„ÅÑ

  const moves = generateMoves(color, state);
  for (const move of moves) {
    const newBoard = applyMove(cloneBoard(state), move);
    if (!isInCheckAfterMove(color, newBoard)) {
      return false; // ÈÄÉ„ÅíÈÅì„Åå„ÅÇ„Çã„Å™„ÇâË©∞„Åø„Åß„ÅØ„Å™„ÅÑ
    }
  }
  return true; // ÂÖ®„Å¶„ÅÆÂêàÊ≥ïÊâã„ÇíË©¶„Åó„Å¶„ÇÇ„ÉÅ„Çß„ÉÉ„ÇØÂõûÈÅø„Åß„Åç„Å™„Åë„Çå„Å∞Ë©∞„Åø
}


setup();
</script>
</body>
</html>
